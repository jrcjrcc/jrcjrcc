<!DOCTYPE html><html><head> <title>游戏：我的世界</title> <meta charset='UTF-8'> <style> body { margin: 0; overflow: hidden; } canvas { display: block; } /* 模态框样式 */ .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; } .modal-content { background-color: white; margin: 15% auto; padding: 20px; width: 300px; text-align: center; border-radius: 5px; } #restartButton { margin-top: 15px; padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; } #restartButton:hover { background-color: #45a049; } </style></head><body style='background-color: #1b073e;'> <p align='center' valign='middle'><canvas id='noiseCanvas'></canvas></p> <div id='gameOverModal' class='modal'> <div class='modal-content'> <h2>游戏结束</h2> <p>得分： <span id='finalScore'>0</span></p> <p font-size='1px'>w/a/s/d移动角色，空格放置方块，躲避怪兽，收集宝箱。</p> <button id='restartButton'>重新开始</button> </div> </div> <script> (function (global) { var module = global.noise = {}; function Grad(x, y, z) { this.x = x; this.y = y; this.z = z; } Grad.prototype.dot2 = function (x, y) { return this.x * x + this.y * y; }; Grad.prototype.dot3 = function (x, y, z) { return this.x * x + this.y * y + this.z * z; }; var grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)]; var p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]; var perm = new Array(512); var gradP = new Array(512); module.seed = function (seed) { if (seed > 0 && seed < 1) { seed *= 65536; } seed = Math.floor(seed); if (seed < 256) { seed |= seed << 8; } for (var i = 0; i < 256; i++) { var v; if (i & 1) { v = p[i] ^ (seed & 255); } else { v = p[i] ^ ((seed >> 8) & 255); } perm[i] = perm[i + 256] = v; gradP[i] = gradP[i + 256] = grad3[v % 12]; } }; module.seed(0); var F2 = 0.5 * (Math.sqrt(3) - 1); var G2 = (3 - Math.sqrt(3)) / 6; var F3 = 1 / 3; var G3 = 1 / 6; module.simplex2 = function (xin, yin) { var n0, n1, n2; var s = (xin + yin) * F2; var i = Math.floor(xin + s); var j = Math.floor(yin + s); var t = (i + j) * G2; var x0 = xin - i + t; var y0 = yin - j + t; var i1, j1; if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; } var x1 = x0 - i1 + G2; var y1 = y0 - j1 + G2; var x2 = x0 - 1 + 2 * G2; var y2 = y0 - 1 + 2 * G2; i &= 255; j &= 255; var gi0 = gradP[i + perm[j]] || grad3[0]; var gi1 = gradP[i + i1 + perm[j + j1]] || grad3[0]; var gi2 = gradP[i + 1 + perm[j + 1]] || grad3[0]; var t0 = 0.5 - x0 * x0 - y0 * y0; if (t0 < 0) { n0 = 0; } else { t0 *= t0; n0 = t0 * t0 * gi0.dot2(x0, y0); } var t1 = 0.5 - x1 * x1 - y1 * y1; if (t1 < 0) { n1 = 0; } else { t1 *= t1; n1 = t1 * t1 * gi1.dot2(x1, y1); } var t2 = 0.5 - x2 * x2 - y2 * y2; if (t2 < 0) { n2 = 0; } else { t2 *= t2; n2 = t2 * t2 * gi2.dot2(x2, y2); } return 70 * (n0 + n1 + n2); }; module.simplex3 = function (xin, yin, zin) { var n0, n1, n2, n3; var s = (xin + yin + zin) * F3; var i = Math.floor(xin + s); var j = Math.floor(yin + s); var k = Math.floor(zin + s); var t = (i + j + k) * G3; var x0 = xin - i + t; var y0 = yin - j + t; var z0 = zin - k + t; var i1, j1, k1; var i2, j2, k2; if (x0 >= y0) { if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } } else { if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } } var x1 = x0 - i1 + G3; var y1 = y0 - j1 + G3; var z1 = z0 - k1 + G3; var x2 = x0 - i2 + 2 * G3; var y2 = y0 - j2 + 2 * G3; var z2 = z0 - k2 + 2 * G3; var x3 = x0 - 1 + 3 * G3; var y3 = y0 - 1 + 3 * G3; var z3 = z0 - 1 + 3 * G3; i &= 255; j &= 255; k &= 255; var gi0 = gradP[i + perm[j + perm[k]]] || grad3[0]; var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]] || grad3[0]; var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]] || grad3[0]; var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]] || grad3[0]; var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0; if (t0 < 0) { n0 = 0; } else { t0 *= t0; n0 = t0 * t0 * gi0.dot3(x0, y0, z0); } var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1; if (t1 < 0) { n1 = 0; } else { t1 *= t1; n1 = t1 * t1 * gi1.dot3(x1, y1, z1); } var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2; if (t2 < 0) { n2 = 0; } else { t2 *= t2; n2 = t2 * t2 * gi2.dot3(x2, y2, z2); } var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3; if (t3 < 0) { n3 = 0; } else { t3 *= t3; n3 = t3 * t3 * gi3.dot3(x3, y3, z3); } return 32 * (n0 + n1 + n2 + n3); }; function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); } function lerp(a, b, t) { return (1 - t) * a + t * b; } module.perlin2 = function (x, y) { var X = Math.floor(x), Y = Math.floor(y); x = x - X; y = y - Y; X = X & 255; Y = Y & 255; var n00 = gradP[X + perm[Y]] ? gradP[X + perm[Y]].dot2(x, y) : 0; var n01 = gradP[X + perm[Y + 1]] ? gradP[X + perm[Y + 1]].dot2(x, y - 1) : 0; var n10 = gradP[X + 1 + perm[Y]] ? gradP[X + 1 + perm[Y]].dot2(x - 1, y) : 0; var n11 = gradP[X + 1 + perm[Y + 1]] ? gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1) : 0; var u = fade(x); return lerp( lerp(n00, n10, u), lerp(n01, n11, u), fade(y)); }; module.perlin3 = function (x, y, z) { var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z); x = x - X; y = y - Y; z = z - Z; X = X & 255; Y = Y & 255; Z = Z & 255; var n000 = gradP[X + perm[Y + perm[Z]]] ? gradP[X + perm[Y + perm[Z]]].dot3(x, y, z) : 0; var n001 = gradP[X + perm[Y + perm[Z + 1]]] ? gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1) : 0; var n010 = gradP[X + perm[Y + 1 + perm[Z]]] ? gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z) : 0; var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]] ? gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1) : 0; var n100 = gradP[X + 1 + perm[Y + perm[Z]]] ? gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z) : 0; var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]] ? gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1) : 0; var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]] ? gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z) : 0; var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]] ? gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1) : 0; var u = fade(x); var v = fade(y); var w = fade(z); return lerp( lerp( lerp(n000, n100, u), lerp(n001, n101, u), w), lerp( lerp(n010, n110, u), lerp(n011, n111, u), w), v); }; })(this); var canvas = document.getElementById('noiseCanvas'); var ctx = canvas.getContext('2d'); function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; } resizeCanvas(); var width = canvas.width = 1400; var height = canvas.height = 1000; var randomNumber = Math.random(); var userSeed = randomNumber; noise.seed(userSeed); var isEnd = -1; var monsters = []; var greenMonsters = []; var trees = []; var chests = []; var hearts = []; var obstacles = []; var enderDoors = []; var woods = 0; var monsterInterval; var hp = 20; for (i = 0; i < 32; i++) { let enderDoor = { x: 0, y: 0 }; enderDoor.x = Math.floor(Math.random() * (width - 100)) + 50; enderDoor.y = Math.floor(Math.random() * (height - 100)) + 50; enderDoors.push(enderDoor); } function moveGreenMonsters() { let playerX = currentStartX + 17; let playerY = currentStartY + 12; greenMonsters = greenMonsters.filter(monster => { const distance = Math.sqrt((monster.x - playerX) ** 2 + (monster.y - playerY) ** 2); return distance <= 20; }); monsters = monsters.filter(monster => { const distance = Math.sqrt((monster.x - playerX) ** 2 + (monster.y - playerY) ** 2); return distance <= 20; }); chests = chests.filter(chest => { const distance = Math.sqrt((chest.x - playerX) ** 2 + (chest.y - playerY) ** 2); return distance <= 20; }); hearts = hearts.filter(heart => { const distance = Math.sqrt((heart.x - playerX) ** 2 + (heart.y - playerY) ** 2); return distance <= 100; }); trees = trees.filter(tree => { const distance = Math.sqrt((tree.x - playerX) ** 2 + (tree.y - playerY) ** 2); return distance <= 20; }); for (let monster of greenMonsters) { try { const dx = playerX - monster.x; const dy = playerY - monster.y; const distance = Math.sqrt(dx * dx + dy * dy); const speed = 0.5 + (distance / 30) * 0.5; const moveX = Math.sign(dx) * speed; const moveY = Math.sign(dy) * speed; if (isGreenWalkable(Math.floor(monster.x + moveX), Math.floor(monster.y + moveY))) { monster.x += moveX; monster.y += moveY; } } catch (error) { console.error('Monster movement error:', error); } } let hasMonsterInScreen = false; for (let monster of monsters) { if (monster.x >= currentStartX + 12 && monster.x < currentStartX + 22 && monster.y >= currentStartY + 10 && monster.y < currentStartY + 14) { hasMonsterInScreen = true; break; } } if (!hasMonsterInScreen) { for (let i = 0; i < 5; i++) { let monster = { x: 0, y: 0 }; do { if (Math.random() < 0.5) { Math.random() < 0.5 ? monster.x = currentStartX + 45 + Math.floor(Math.random() * 20 - 10) : monster.x = currentStartX - 10 + Math.floor(Math.random() * 20 - 10); monster.y = currentStartY + 12 + Math.floor(Math.random() * 40 - 20); } else { monster.x = currentStartX + 17 + Math.floor(Math.random() * 40 - 20); Math.random() < 0.5 ? monster.y = currentStartY + 35 + Math.floor(Math.random() * 20 - 10) : monster.y = currentStartY - 10 + Math.floor(Math.random() * 20 - 10); } } while (!isWalkable(monster.x, monster.y)); monsters.push(monster); if (monsters.length > 64) { monsters.shift(); } } } let hasGreenMonsterInScreen = false; for (let monster of greenMonsters) { if (monster.x >= currentStartX + 12 && monster.x < currentStartX + 22 && monster.y >= currentStartY + 10 && monster.y < currentStartY + 14) { hasGreenMonsterInScreen = true; break; } } if (!hasGreenMonsterInScreen) { for (let i = 0; i < 2; i++) { let monster = { x: 0, y: 0 }; do { if (Math.random() < 0.5) { Math.random() < 0.5 ? monster.x = currentStartX + 45 + Math.floor(Math.random() * 20 - 10) : monster.x = currentStartX - 10 + Math.floor(Math.random() * 20 - 10); monster.y = currentStartY + 12 + Math.floor(Math.random() * 40 - 20); } else { monster.x = currentStartX + 17 + Math.floor(Math.random() * 40 - 20); Math.random() < 0.5 ? monster.y = currentStartY + 35 + Math.floor(Math.random() * 20 - 10) : monster.y = currentStartY - 10 + Math.floor(Math.random() * 20 - 10); } } while (!isWalkable(monster.x, monster.y)); greenMonsters.push(monster); if (greenMonsters.length > 15) { greenMonsters.shift(); } } } let hasTreeInScreen = false; for (let tree of trees) { if (tree.x >= currentStartX + 12 && tree.x < currentStartX + 22 && tree.y >= currentStartY + 10 && tree.y < currentStartY + 14) { hasTreeInScreen = true; break; } } if (!hasTreeInScreen) { for (let i = 0; i < 5; i++) { let tree = { x: 0, y: 0 }; do { Math.random() < 0.5 ? tree.x = currentStartX + 45 + Math.floor(Math.random() * 20 - 10) : tree.x = currentStartX - 10 + Math.floor(Math.random() * 20 - 10); tree.y = currentStartY + 12 + Math.floor(Math.random() * 40 - 20); } while (!isWalkable(tree.x, tree.y)); trees.push(tree); do { tree.x = currentStartX + 17 + Math.floor(Math.random() * 40 - 20); Math.random() < 0.5 ? tree.y = currentStartY + 35 + Math.floor(Math.random() * 20 - 10) : tree.y = currentStartY - 10 + Math.floor(Math.random() * 20 - 10); } while (!isWalkable(tree.x, tree.y)); trees.push(tree); } if (trees.length > 64) { trees.shift(); } } let hasChestInScreen = false; for (let chest of chests) { if (chest.x >= currentStartX + 12 && chest.x < currentStartX + 22 && chest.y >= currentStartY + 10 && chest.y < currentStartY + 14) { hasChestInScreen = true; break; } } if (!hasChestInScreen) { for (let i = 0; i < 2; i++) { let chest = { x: 0, y: 0 }; do { if (Math.random() < 0.5) { Math.random() < 0.5 ? chest.x = currentStartX + 45 + Math.floor(Math.random() * 20 - 10) : chest.x = currentStartX - 10 + Math.floor(Math.random() * 20 - 10); chest.y = currentStartY + 12 + Math.floor(Math.random() * 40 - 20); } else { chest.x = currentStartX + 17 + Math.floor(Math.random() * 40 - 20); Math.random() < 0.5 ? chest.y = currentStartY + 35 + Math.floor(Math.random() * 20 - 10) : chest.y = currentStartY - 10 + Math.floor(Math.random() * 20 - 10); } } while (!isWalkable(chest.x, chest.y)); chests.push(chest); if (chests.length > 20) { chests.shift(); } } } let hasHeartInScreen = false; for (let heart of hearts) { if (heart.x >= currentStartX - 30 && heart.x < currentStartX + 65 && heart.y >= currentStartY - 20 && heart.y < currentStartY + 40) { hasHeartInScreen = true; break; } } if (!hasHeartInScreen) { for (let i = 0; i < 1; i++) { let heart = { x: 0, y: 0 }; do { if (Math.random() < 0.5) { Math.random() < 0.5 ? heart.x = currentStartX + 45 + Math.floor(Math.random() * 20 - 10) : heart.x = currentStartX - 10 + Math.floor(Math.random() * 20 - 10); heart.y = currentStartY + 12 + Math.floor(Math.random() * 40 - 20); } else { heart.x = currentStartX + 17 + Math.floor(Math.random() * 40 - 20); Math.random() < 0.5 ? heart.y = currentStartY + 35 + Math.floor(Math.random() * 20 - 10) : heart.y = currentStartY - 10 + Math.floor(Math.random() * 20 - 10); } } while (!isWalkable(heart.x, heart.y)); hearts.push(heart); if (hearts.length > 10) { hearts.shift(); } } } drawNoise(currentStartX, currentStartY); } function moveMonsters() { let playerX = currentStartX + 17; let playerY = currentStartY + 12; for (let monster of monsters) { try { const directions = [ { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 }, { x: 0, y: 0 } ]; const randomDirection = directions[Math.floor(Math.random() * directions.length)]; const newX = monster.x + randomDirection.x; const newY = monster.y + randomDirection.y; if (isWalkable(newX, newY)) { monster.x = newX; monster.y = newY; } const distance = Math.sqrt((monster.x - playerX) ** 2 + (monster.y - playerY) ** 2); } catch (error) { console.error('Monster movement error:', error); } } drawNoise(currentStartX, currentStartY); } function initMonsters() { for (let i = 0; i < 10; i++) { let monster = { x: 0, y: 0 }; do { monster.x = currentStartX + 17 + Math.floor(Math.random() * 10 - 5) + (2 * Math.floor(Math.random() * 2) - 1) * 17; monster.y = currentStartY + 12 + Math.floor(Math.random() * 8 - 4) + (2 * Math.floor(Math.random() * 2) - 1) * 12; } while (!isWalkable(monster.x, monster.y)); monsters.push(monster); } } function initGreenMonsters() { for (let i = 0; i < 2; i++) { let monster = { x: 0, y: 0 }; do { monster.x = currentStartX + 17 + Math.floor(Math.random() * 40 - 20) + (2 * Math.floor(Math.random() * 2) - 1) * 17; monster.y = currentStartY + 12 + Math.floor(Math.random() * 40 - 20) + (2 * Math.floor(Math.random() * 2) - 1) * 12; } while (!isWalkable(monster.x, monster.y)); greenMonsters.push(monster); } } function initTrees() { for (let i = 0; i < 30; i++) { let tree = { x: 0, y: 0 }; do { tree.x = currentStartX + 17 + Math.floor(Math.random() * 80 - 40); tree.y = currentStartY + 12 + Math.floor(Math.random() * 80 - 40); } while (!isWalkable(tree.x, tree.y)); trees.push(tree); } } function initChests() { for (let i = 0; i < 10; i++) { let chest = { x: 0, y: 0 }; do { chest.x = currentStartX + 17 + Math.floor(Math.random() * 80 - 40); chest.y = currentStartY + 12 + Math.floor(Math.random() * 80 - 40); } while (!isWalkable(chest.x, chest.y)); chests.push(chest); } } function initHearts() { for (let i = 0; i < 1; i++) { let heart = { x: 0, y: 0 }; do { heart.x = currentStartX + 17 + Math.floor(Math.random() * 80 - 40); heart.y = currentStartY + 12 + Math.floor(Math.random() * 80 - 40); } while (!isWalkable(heart.x, heart.y)); hearts.push(heart); } } monsterInterval = setInterval(moveMonsters, 250); function isWalkable(x, y) { var noiseValue = getColorAtPosition(x, y); for (var obstacle of obstacles) { if (obstacle.x === x && obstacle.y === y) { return false; } } return noiseValue >= -0.35; } function isGreenWalkable(x, y) { var noiseValue = getColorAtPosition(x, y); for (var obstacle of obstacles) { if (obstacle.x === x && obstacle.y === y) { return false; } } return true; } function getHeightColor(height) { var points = [ { height: 0.15, color: [0, 0, 200] }, { height: 0.33, color: [0, 128, 255] }, { height: 0.3301, color: [70, 90, 30] }, { height: 0.85, color: [0, 170, 0] }, { height: 1.00, color: [200, 200, 200] }, { height: 1.30, color: [255, 229, 204] } ]; isEnd == -1 ? points = [ { height: 0.15, color: [0, 0, 200] }, { height: 0.33, color: [0, 128, 255] }, { height: 0.3301, color: [70, 90, 30] }, { height: 0.85, color: [0, 170, 0] }, { height: 1.00, color: [200, 200, 200] }, { height: 1.30, color: [255, 229, 204] } ] : points = [ { height: 0.15, color: [255, 90, 0] }, { height: 0.33, color: [255, 0, 0] }, { height: 0.3301, color: [50, 0, 0] }, { height: 0.85, color: [150, 20, 0] }, { height: 1.00, color: [150, 90, 50] }, { height: 1.20, color: [255, 200, 150] }, { height: 1.2001, color: [255, 0, 0] }, { height: 1.35, color: [255, 90, 0] }, { height: 1.50, color: [255, 200, 0] } ]; height = (height + 1) / 2; for (var i = 0; i < points.length - 1; i++) { if (height < points[i + 1].height) { var t = (height - points[i].height) / (points[i + 1].height - points[i].height); var r = lerp(points[i].color[0], points[i + 1].color[0], t); var g = lerp(points[i].color[1], points[i + 1].color[1], t); var b = lerp(points[i].color[2], points[i + 1].color[2], t); return 'rgb(' + Math.floor(r) + ',' + Math.floor(g) + ',' + Math.floor(b) + ')'; } } return 'rgb(' + points[points.length - 1].color[0] + ',' + points[points.length - 1].color[1] + ',' + points[points.length - 1].color[2] + ')'; } function lerp(a, b, t) { return (1 - t) * a + t * b; } function getColorAtPosition(x, y) { var scale = 0.35; var centerX = x * 1 + 1 / 2; var centerY = y * 1 + 1 / 2; var noiseValue = 1.3 * noise.simplex2(0.03 * centerX * scale, 0.03 * centerY * scale) + 0.2 * noise.simplex2(centerX * scale, centerY * scale) + noise.simplex2(0.1 * centerX * scale, 0.1 * centerY * scale) + 0.5 * noise.simplex2(0.2 * centerX * scale, 0.2 * centerY * scale) + 0.2 * noise.simplex2(0.5 * centerX * scale, 0.5 * centerY * scale) + 0.000 * noise.simplex2(7 * centerX * scale, 7 * centerY * scale); return noiseValue; } function drawNoise(startX, startY) { var scale = 0.35; var cellWidth = 40; var cellHeight = 40; var endX = startX + 35; var endY = startY + 25; ctx.clearRect(0, 0, canvas.width, canvas.height); for (var x = startX; x < endX; x++) { for (var y = startY; y < endY; y++) { var centerX = x * 1 + 1 / 2; var centerY = y * 1 + 1 / 2; var noiseValue = 1.3 * noise.simplex2(0.03 * centerX * scale, 0.03 * centerY * scale) + 0.2 * noise.simplex2(centerX * scale, centerY * scale) + noise.simplex2(0.1 * centerX * scale, 0.1 * centerY * scale) + 0.5 * noise.simplex2(0.2 * centerX * scale, 0.2 * centerY * scale) + 0.2 * noise.simplex2(0.5 * centerX * scale, 0.5 * centerY * scale) + 0.000 * noise.simplex2(7 * centerX * scale, 7 * centerY * scale); var color = getHeightColor(noiseValue); ctx.fillStyle = color; ctx.fillRect((x - startX) * cellWidth, (y - startY) * cellHeight, cellWidth, cellHeight); } } if (getColorAtPosition(startX + 17, startY + 13) < -0.35 || (getColorAtPosition(startX + 17, startY + 13) > 1.37 && isEnd == 1)) { isEnd == 1 ? monsterInterval = 50 : movementInterval = 125; clearInterval(intervalId); intervalId = setInterval(function () { if (keyState['w']) { isEnd == 1 ? currentStartY = Math.max(0, currentStartY - 0.25) : currentStartY = Math.max(0, currentStartY - 0.50); } if (keyState['a']) { isEnd == 1 ? currentStartX = Math.max(0, currentStartX - 0.25) : currentStartX = Math.max(0, currentStartX - 0.50); } if (keyState['s']) { isEnd == 1 ? currentStartY = Math.min(canvas.height - 13, currentStartY + 0.25) : currentStartY = Math.min(canvas.height - 13, currentStartY + 0.50); } if (keyState['d']) { isEnd == 1 ? currentStartX = Math.min(canvas.width - 21, currentStartX + 0.25) : currentStartX = Math.min(canvas.width - 21, currentStartX + 0.50); } if (keyState['`']) { hp++; woods++; score += 10; } isEnd == 1 ? hp -= 0.1 : hp = hp; if (hp <= 0) { gameOver(); } drawNoise(currentStartX, currentStartY); }, movementInterval); } else { movementInterval = 100; clearInterval(intervalId); intervalId = setInterval(function () { if (keyState['w']) { currentStartY = Math.floor(Math.max(0, currentStartY - 1)); } if (keyState['a']) { currentStartX = Math.floor(Math.max(0, currentStartX - 1)); } if (keyState['s']) { currentStartY = Math.floor(Math.min(canvas.height - 13, currentStartY + 1)); } if (keyState['d']) { currentStartX = Math.floor(Math.min(canvas.width - 21, currentStartX + 1)); } if (keyState['`']) { hp++; woods++; score += 10; } if (keyState[' ']) { var obstacleX = currentStartX + 17; var obstacleY = currentStartY + 13; var obstacleX = currentStartX + 17; var obstacleY = currentStartY + 13; if (isWalkable(obstacleX, obstacleY) && obstacles.length < woods) { obstacles.push({ x: obstacleX, y: obstacleY }); } } drawNoise(currentStartX, currentStartY); }, movementInterval); } for (let monster of monsters) { if (monster.x >= startX && monster.x < startX + 35 && monster.y >= startY && monster.y < startY + 25) { var cellWidth = 40; var drawX = (monster.x - startX) * cellWidth; var drawY = (monster.y - startY) * cellWidth; isEnd == 1 ? ctx.fillStyle = 'rgba(0, 0, 0, 0.5)' : ctx.fillStyle = 'rgba(255, 0, 0, 1)'; ctx.fillRect(Math.floor(drawX / 40) * 40, Math.floor(drawY / 40) * 40, cellWidth, cellHeight); isEnd == 1 ? ctx.fillStyle = 'white' : ctx.fillStyle = 'black'; ctx.fillRect(Math.floor(drawX / 40) * 40 + 10, Math.floor(drawY / 40) * 40 + 10, 5, 5); ctx.fillRect(Math.floor(drawX / 40) * 40 + 25, Math.floor(drawY / 40) * 40 + 10, 5, 5); ctx.fillRect(Math.floor(drawX / 40) * 40 + 12, Math.floor(drawY / 40) * 40 + 25, 15, 5); } } for (let monster of greenMonsters) { if (monster.x >= startX && monster.x < startX + 35 && monster.y >= startY && monster.y < startY + 25) { var cellWidth = 40; var drawX = (monster.x - startX) * cellWidth; var drawY = (monster.y - startY) * cellWidth; isEnd == 1 ? ctx.fillStyle = 'rgba(50, 150, 30, 1)' : ctx.fillStyle = 'purple'; ctx.fillRect(Math.floor(drawX / 40) * 40, Math.floor(drawY / 40) * 40, cellWidth, cellHeight); ctx.fillStyle = 'black'; ctx.fillRect(Math.floor(drawX / 40) * 40 + 10, Math.floor(drawY / 40) * 40 + 10, 5, 5); ctx.fillRect(Math.floor(drawX / 40) * 40 + 25, Math.floor(drawY / 40) * 40 + 10, 5, 5); ctx.fillRect(Math.floor(drawX / 40) * 40 + 12, Math.floor(drawY / 40) * 40 + 25, 15, 5); } } for (let tree of trees) { if (tree.x >= startX && tree.x < startX + 35 && tree.y >= startY && tree.y < startY + 25) { var cellWidth = 40; var drawX = (tree.x - startX) * cellWidth; var drawY = (tree.y - startY) * cellWidth; ctx.fillStyle = 'brown'; ctx.fillRect(Math.floor(drawX / 40) * 40 + 15, Math.floor(drawY / 40) * 40 + 25, 10, 15); isEnd == 1 ? ctx.fillStyle = 'rgb(200,150,50)' : ctx.fillStyle = 'green'; ctx.fillRect(Math.floor(drawX / 40) * 40, Math.floor(drawY / 40) * 40 - 10, 40, 35); } } for (let chest of chests) { if (chest.x >= startX && chest.x < startX + 35 && chest.y >= startY && chest.y < startY + 25) { var cellWidth = 40; var drawX = (chest.x - startX) * cellWidth; var drawY = (chest.y - startY) * cellWidth; ctx.fillStyle = 'gold'; ctx.fillRect(Math.floor(drawX / 40) * 40, Math.floor(drawY / 40) * 40, cellWidth, cellHeight); ctx.fillStyle = 'black'; ctx.fillRect(Math.floor(drawX / 40) * 40 + 17, Math.floor(drawY / 40) * 40 + 5, 5, 20); ctx.fillRect(Math.floor(drawX / 40) * 40 + 17, Math.floor(drawY / 40) * 40 + 30, 5, 5); } } for (let heart of hearts) { if (heart.x >= startX && heart.x < startX + 35 && heart.y >= startY && heart.y < startY + 25) { var cellWidth = 40; var drawX = (heart.x - startX) * cellWidth; var drawY = (heart.y - startY) * cellWidth; isEnd == 1 ? ctx.fillStyle = 'rgba(200, 0, 0, 1)' : ctx.fillStyle = 'rgba(0, 0, 255, 1)'; ctx.fillRect(Math.floor(drawX / 40) * 40, Math.floor(drawY / 40) * 40 + 10, cellWidth, cellHeight - 20); ctx.fillRect(Math.floor(drawX / 40) * 40 + 5, Math.floor(drawY / 40) * 40 + 10, cellWidth - 10, cellHeight - 15); ctx.fillRect(Math.floor(drawX / 40) * 40 + 7, Math.floor(drawY / 40) * 40 + 3, 10, 10); ctx.fillRect(Math.floor(drawX / 40) * 40 + 23, Math.floor(drawY / 40) * 40 + 3, 10, 10); ctx.fillRect(Math.floor(drawX / 40) * 40 + 15, Math.floor(drawY / 40) * 40 + 30, 10, 10); } } let playerX = currentStartX + 17; let playerY = currentStartY + 12; chests = chests.filter(chest => { if (Math.sqrt((playerX - chest.x) ** 2 + (playerY - chest.y) ** 2) < 1.5) { score += 10; } return !(Math.sqrt((playerX - chest.x) ** 2 + (playerY - chest.y) ** 2) < 1.5); }); hearts = hearts.filter(heart => { if (Math.sqrt((playerX - heart.x) ** 2 + (playerY - heart.y) ** 2) < 1.5) { hp += 2; if (hp > 20) { hp = 20; } } return !(Math.sqrt((playerX - heart.x) ** 2 + (playerY - heart.y) ** 2) < 1.5); }); for (let monster of monsters) { if (Math.sqrt((playerX - monster.x) ** 2 + (playerY - monster.y) ** 2) < 1.1) { hp -= 1; if (Math.sqrt((playerX - monster.x) ** 2 + (playerY - monster.y) ** 2) < 0.8) { hp = Math.min(hp - 1, 8); } if (hp <= 0) { gameOver(); } } } for (let greenMonster of greenMonsters) { if (Math.sqrt((playerX - greenMonster.x) ** 2 + (playerY - greenMonster.y) ** 2) < 1.5) { hp -= 0.2; if (Math.sqrt((playerX - greenMonster.x) ** 2 + (playerY - greenMonster.y) ** 2) < 0.8) { hp -= 1; } if (hp <= 0) { gameOver(); } } } for (let tree of trees) { if (Math.sqrt((playerX - tree.x) ** 2 + (playerY - tree.y) ** 2) < 1.5) { woods += 1; trees.splice(trees.indexOf(tree), 1); score += 1; } } for (let door of enderDoors) { if (door.x >= startX && door.x < startX + 35 && door.y >= startY && door.y < startY + 25) { var cellWidth = 40; var drawX = (door.x - startX) * cellWidth; var drawY = (door.y - startY) * cellWidth; ctx.fillStyle = '#05012F'; ctx.fillRect(Math.floor(drawX / 40) * 40 - 60, Math.floor(drawY / 40) * 40 - 80, cellWidth * 4, cellHeight * 5); ctx.fillStyle = 'purple'; ctx.fillRect(Math.floor(drawX / 40) * 40 - 20, Math.floor(drawY / 40) * 40 - 40, cellWidth * 2, cellHeight * 3); } } for (let door of enderDoors) { if (Math.sqrt((playerX - door.x) ** 2 + (playerY - door.y) ** 2) < 3) { isEnd *= -1; currentStartX += Math.floor(Math.random() * 80) - 40; currentStartY += Math.floor(Math.random() * 80) - 40; score += 10; drawNoise(currentStartX, currentStartY); } } ctx.fillStyle = '#CD853F'; ctx.fillRect((17) * cellWidth, (12) * cellHeight, cellWidth, cellHeight); ctx.fillStyle = 'black'; ctx.fillRect((17) * cellWidth + 10, (12) * cellHeight + 10, 5, 5); ctx.fillRect((17) * cellWidth + 25, (12) * cellHeight + 10, 5, 5); ctx.fillRect((17) * cellWidth + 12, (12) * cellHeight + 25, 15, 5); ctx.fillStyle = '#008B8B'; ctx.fillRect((17) * cellWidth, (13) * cellHeight, cellWidth, cellHeight); var cellWidth = 40; var drawX = (playerX - startX) * cellWidth; var drawY = (playerY - startY) * cellWidth; ctx.fillStyle = 'red'; for (let obstacle of obstacles) { if (obstacle.x >= startX && obstacle.x < startX + 35 && obstacle.y >= startY && obstacle.y < startY + 25) { var cellWidth = 40; var drawX = (obstacle.x - startX) * cellWidth; var drawY = (obstacle.y - startY) * cellWidth; ctx.fillStyle = 'brown'; ctx.fillRect(Math.floor(drawX / 40) * 40, Math.floor(drawY / 40) * 40, cellWidth, cellHeight); } } ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(10, 10, 160, 15); ctx.fillStyle = 'rgba(200, 0, 0, 1)'; ctx.fillRect(10, 10, Math.max(hp * 8, 0), 15); ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(10, 30, 160, 15); ctx.fillStyle = 'rgba(0, 0, 200, 1)'; ctx.fillRect(10, 30, Math.min(score, 160), 15); ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(10, 50, 160, 15); ctx.fillStyle = 'rgba(0, 200, 0, 1)'; ctx.fillRect(10, 50, Math.min((woods - obstacles.length) * 8, 160), 15); } var currentStartX = 700; var currentStartY = 500; let keyState = {}; let movementInterval = 125; var intervalId; initMonsters(); initGreenMonsters(); initTrees(); initChests(); greenMonsterInterval = setInterval(moveGreenMonsters, 250); document.addEventListener('keydown', function (event) { keyState[event.key] = true; }); document.addEventListener('keyup', function (event) { keyState[event.key] = false; }); var intervalId; document.addEventListener('keydown', function (e) { keyState[e.key] = true; }); document.addEventListener('keyup', function (e) { keyState[e.key] = false; }); intervalId = setInterval(function () { if (keyState['w']) { currentStartY = Math.max(0, currentStartY - 1); } if (keyState['a']) { currentStartX = Math.max(0, currentStartX - 1); } if (keyState['s']) { currentStartY = Math.min(canvas.height - 13, currentStartY + 1); } if (keyState['d']) { currentStartX = Math.min(canvas.width - 21, currentStartX + 1); } drawNoise(currentStartX, currentStartY); }, movementInterval); var board = []; drawNoise(currentStartX, currentStartY); var startTime = Date.now(); var score = 0; var timerInterval = setInterval(function () { score += -1; if (score < 0) { score = 0; } }, 1000); function gameOver() { clearInterval(timerInterval); clearInterval(monsterInterval); clearInterval(intervalId); document.getElementById('gameOverModal').style.display = 'block'; document.getElementById('finalScore').textContent = score; } document.getElementById('restartButton').addEventListener('click', function () { location.reload(); }); </script></body></html>