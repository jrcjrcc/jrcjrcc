#1

1‎关于C#和.NET的关系描述错误的是( )。

- A.C#是一个程序设计语言，运行在.net平台上用于创建应用程序
- B.CLR是公共语言运行时，是提供内在管理，代码安全性检测等功能
- C.Visual Studio是一个集成开发环境，可用于C#语言和.netFramework的交互
- ==D..NET是微软开发的一个硬件平台==

2在C#中任何（ ）都是对象

- ‏A.任何类型
- ==B.任何事物==
- C.任何技术
- D.任何代码

3‌对象包含数据和（ ）的方法

- ==A.该数据上工作==
- B.传递参数
- C.函数调用
- D.调用

4‍以下描述正确的是（ ）

- A.以上都正确
- B.Console是C#系统的输出类
- ==C.Console.ReadLine()方法的返回值为字符串==
- D.Console.Write是向控制台输出一个字符

5‌执行下列代码，如果在控制台输入123，以下描述正确的是（ ）

‌int x;

‌x=Console.ReadLine();

- A.x的值是字符串"123"
- B.x的值是整形123
- C.报错，无法将int类型隐式转换为string
- ==D.报错，无法将string类型隐式转换为int==

6执行以下代码，以下描述正确的是（）

`Console.WriteLine("现在的得分是{0}比{1}","2","3");`

- ==A.现在的得分是2比3==
- B.现在的得分是0比1
- C.现在的得分是2比1
- D.现在的得分是0比2

7执行C#代码的过程包括（ ）。

- ==A.选择编译器==
- ==B.将MSIL编译为本机代码==
- ==C.将代码编译为MSIL==
- ==D.运行代码==

8‌用C#写的应用程序就是.NET程序。X

9‏CLR是公共语言运行时，独立于CPU的指令集，可以被转换为特定与某种CPU的代码。V

10‍C#源程序的后缀名是.cs。V

11‍Visual Studio的解决方案资源管理器，包含一个项目的所有文件和组件。V



# 2

1在C#中，以下描述错误的是（）

- A.逻辑运算符的运算结果是布尔值
- B.关系运算符用于比较两个操作数的大小
- C.关系运算符的运算结果是布尔值
- ==D.逻辑运算符用于比较两个操作数的大小==

2‍下列运算附中属于关系运算符的是（ ）

- A.-=
- B.+=
- ==C.\=\===
- D.=

3‌以下表示“a>3 或 a<0”的C#表达式的是（ ）

- ==A.a>3 || a<0==
- B.a>3 | a<0
- C.a>3 or a<0
- D.a>3 && a<0

4‍如果定义的变量表示的是银行的存款，则最好选（ ）类型

- ==A.decimal==
- B.int
- C.double
- D.float

5‍以下变量名不合法的是（ ）

- A._hebi
- B.yamaha
- C.名字
- ==D.123Nameis==

6以下赋值语句错误的是（）

- A.decimal d1=1.0m;
- B.int i=’a’;
- ==C.char ch=9;==
- D.var name=“张龙”;

7‏以下赋值语句合法的是（ ）

- A.int x==1;
- ==B.int x,y; x= y=1;==
- C.int x=y=1;
- D.int x=1;y=1;

8以下代码执行后，不会报错的是（ ）

‌`int i = 0;`

`‌decimal d = 0;`

`‌float f = 0;`

`char ch=’\0’;`

- A.Console.WriteLine(10/ch);
- B.Console.WriteLine(10/d);
- C.Console.WriteLine(10/i);
- ==D.Console.WriteLine(10/f);==    `返回Infinity`

9‎C#中的数值0表示bool类型的false，数值1表示bool类型的true。X

10‌char类型的本质上是整数。可以直接赋值给int，long型变量。V

11‌char.IsUpper和char.IsLower分别用来判断字符是大写还是小写。V

12‍枚举类型的元素默认值类型是int。每个元素的值按照定义的顺序依次加1必须连续。X

13‌Convert类支持数据类型的显示转换。如Convert.ToInt32(1.5)的结果是1。X

14‌int a=1; int b=a++; b的值是2。X

# 3

1‍面向对象思想的三大基本特征是

- A.抽象，继承，派生
- B.对象，属性，方法
- ==C.继承，封装，多态==
- D.类，对象，方法

2关于类成员的访问修饰符，描述错误的是

- A.public修饰的成员方法，在类实例化调用时，可用“对象名.方法名（）”调用。
- B.private私有成员和私有字段成员只能被类内部的方法使用和修改。
- ==C.在类前添加访问修饰符，声明了类内部成员对该类的访问权限。==
- D.在类声明时，访问修饰符是可选部分。

3‎关于静态字段的描述，错误是

- A.一个类的所有对象共享静态字段。
- ==B.静态函数成员能访问实例成员和静态成员。==
- C.如果静态字段的值被一个实例改变，所有实例都可见。
- D.static修饰符声明的字段为静态字段。

4‍关于属性的使用正确的是

- ==A.==

    ==private int num;==

    ==public int Num==

    =={==

    ==get{return num;}==

    ==set{num=value;}==

    ==}==

    

- B.

    private int num;

    public string Num

    {

    get{return num;} 

    set{num=value;}

    }

- C.

    private int num;

    public int Num

    {

    get{num=value;}

    set{return num;}

    }

- D.

    private int num;

    private int Num

    {

    get{return num;}

    set{num=value;}

    }

5C#中的数据类型的描述，错误的是

- ==A.简单类型如int，double，float，bool，string等是值类型。==
- B.类类型属于引用类型，默认值是null。
- C.C#中的数据类型分为值类型和引用类型。
- D.int类型的默认值是0，bool类型默认值是false。

6关于值类型和引用类型，描述正确的是

- ==A.值类型变量直接存放真正的数据，引用类型变量存放的是指向真正数据的内存地址==
- B.所有内置的数据类型都是值类型，所有用户定义的数据类型都是引用类型
- C.string属于值类型
- D.struct属于引用类型

7‍以下的描述错误的是

- ==A.类的默认访问修饰符是public。==
- B.C#没有全局变量，所有的变量都是在类中声明。
- C.类的关键字是class。
- D.new关键字的作用是类的实例化。

8‌关于属性的描述，正确的是

- A.属性的get方法能修改实例变量的值。
- B.属性的声明必须同时包含get方法和set方法。
- ==C.属性的set方法能够修改实例变量的值。==
- ==D.用private声明的属性，只能由声明它的类访问。==

9Console.ReadLine读取字符，遇换行符停止，然后将这些字符做为string返回。V

10‎在调用方法时，实参个数和类型必须与被调用的方法声明参数表中的参数个数和类型一致。V

11‌局部变量的作用域在声明它的方法内。V

12‏const修饰的常量在声明中可以初始化也可以不初始化。X

13‍类实例的值类型成员，分配内存中的栈空间。X

14‍关键字readonly表明对象或者变量在初始化后不能修改。V

# 4

1‍以下描述中，错误的是

‍

-   ==A.switch语句中的break语句是必须的，和case语句成对儿出现。==
-   B.C#有三种控制语句：顺序、选择、循环。
-   C.if语句条件为false时，跳过if语句块{}，执行else语句块，若没有else语句，顺序执行后面的语句。
-   D.选择结构有if语句，if...else…语句，switch语句三种。

2‌以下if…else…结构执行结果是

‌`int x=80;`
`int y=30;`
‌`if ( x <0 || x>75 )`

‌`{ `
‌ ` if(y>=80)`
`	{`
`		Console.Write(“晴”);`
`	}`
‌ ` else`
‌`  {`
‌  `  Console.Write(“晴转阴”);`
‌  `}`
‌`}`
‌`else`
‌`{`
‌ ` Console.Write(“ 阴”);`
‌`}`

-   A.晴转阴 阴
-   ==B.晴转阴==
-   C.晴
-   D.晴 阴

3以下for语句的表示方法，错误的是

-   A.int i;

    for(i=0; i<10; i++){}

-   B.for(int i=0; i<10; ){}

-   ==C.for( int i=0, i<10, i++){}==

-   D.int i=0;

    for(i; i<10; i++){}

4‎如果month=4，下面代码的输出结果是‍

‎int days=0；

‎switch(month)

‍‎{

‍‎case 2:

‍‎days=28;

‍‎break;

‍‎case 4:

‍‎case 6:

‍‎case 9:

‍‎case 11:

‍‎  days=30;

‍‎  break;

‍‎default:

‍‎  days=31;

‍‎  break;

‍‎}

‍‎Console.WriteLine(days); 

-   A.30

-   B.0

-   C.31

-   D.28

5‏有关对foreach语句描述不正确的是

-   ==A.可以在foreach语句体中改变迭代变量的值。==

-   B.foreach语句的语法为：foreach(type identifier in arrayName){statement;}

-   C.其中type和identifier分别表示迭代变量的类型和名称，arrayName表示要迭代的数组。

-   D.foreach语句只能用来访问数组元素。


6‏下面程序的输出结果是

‏      string str = "a123bc456d";

‏      string result = "";

‏      for (int i = 0; str[i] >= 'a' && str[i] <= 'z'; i += 1)

‏      {

‏        result = str[i] + result;

‏        Console.WriteLine(result);

‏      }

-   A.abcd

-   ==B.a==

-   C.编译出错，无法运行

-   D.123456


7以下哪种循环语句的循环体可能被执行0次

-   ==A.while==

-   ==B.foreach==

-   ==C.for==

-   D.do…while


8‏关于跳转语句break和continue，以下说法正确的是

-   A.break是中断本次循环，进入下一次的循环。

-   ==B.continue是中断本次循环，进入下一次的循环。==

-   C.continue是中断整个循环。

-   ==D.break是中断整个循环。==

9‎switch语句的关键字case后面的表达式可以是整形、字符型、字符串型。V

10‌while循环语句，一定要有修改循环条件的语句，否则会造成死循环。V

11‎while，do…while，for和foreach循环语句的循环体只有当条件为真时才执行。X

12‎foreach语句用于遍历数组中的元素，也可改变元素的值。X

13‍switch语句中的default语句是可选的，也可有多个。X

#5

1‍下面对数组的描述错误的是（ ）

-   A.数组是固定长度的实体，一旦创建，就会保持长度不变
-   B.数组的元素可以是值类型或引用类型
-   C.数组是一种数据结构，它由相同类型的相关数据项组成
-   ==D.数组是值类型==

2‌C#数组有三种形式，它们是：（ ）

-   A.一维数组、二维数组、三维数组
-   B.整形数组、浮点型数组、字符型数组
-   C.一维数组、二维数组、多维数组
-   ==D.一维数组、多维数组、交错数组==

3数组scores定义如下：

int[] scores=new int[5]{65,71,90,68,80};

则scores[1]=（ ）

-   ==A.71==
-   B.80
-   C.未知，编译报错
-   D.65

4下面声明和创建数组的语句错误的是（ ）

-   A.int[] n={1,2,3,4,5};

-   B.int[] c;

    c=new int[12];

-   ==C.int[] array = new int[3] {1,2};==

-   D.int[] a=new int[12];

5关于多维数组的描述正确的是（ ）‍

-   A.用arrayName[row,column]形式可以访问到交错数组中的元素
-   ==B.二维数组用来表示值表，它将信息存放在行和列中，为了确定某个表元素，必须指定两个索引==
-   C.交错数组各行长度必须相同
-   D.矩阵数组用行和列的形式表示表信息，每行的列数可以不同

6‎在调用方法时，如果想给方法传递任意个数的参数时，应选哪个关键字（）‌

-   A.any
-   ==B.params==
-   C.ref
-   D.无法实现

7‍有一个定义了变长实参的方法，其方法头为：‍

‍    public static double getAverage(params double[] numbers){…}‍

‍下面调用该方法正确的是：（ ）‍

-   A.double d1= getAverage (1);

-   B.double[] arrayDouble={1.0,2.0,3.0,4.0};

    double d4= getAverage(arrayDouble);

-   C.double d2= getAverage (10.0,20.0,30.0);

-   ==D.以上写法都正确==

8‏下面代码是实现数组array冒泡排序的片段，划线处应填入（ ）‌

  int[] array = { 60, 56, 38, 45 };‌

‏      int temp;‌

‏      for (int i = 0; i < 3; i++)‌

‏      {    ‌

‏        for (int j = 0; j < __________; j++)‌

‏        {‌

‏          if (array[j] < array[j + 1])‌

‏          {‌

‏             temp = array[j];‌

‏             array[j] = array[j + 1]; ‌

‏             array[j + 1] = temp; }‌

‏        }‌

‏      }‌

-   A.i
-   B.i+1
-   ==C.3-i==
-   D.4-i

# 6

1‏在下列代码中，有（ ）处实现了拆箱。

‌‏int score=5;‌

‏object o= score;‌

‏o=10;‌

‏score =(int)o;‌

‏object oScore = score;‌

-   A.3
-   B.0
-   C.2
-   ==D.1==

2‍下面控制对成员访问描述错误的是（ ）‏

-   A.如果一个类试图去使用另一个类的私有成员，则编译器会产生错误消息，提示这些私有成员无法访问
-   B.对于类的私有变量和私有方法，类的对象无法直接访问的
-   C.访问修饰符public和private控制着对类的变量、方法和属性的访问
-   ==D.如果类的成员没有用访问修饰符声明，则默认为共有的==

3‌有关this引用访问当前对象成员的描述正确的是（）

-   ==A.每个对象都可以用关键字this引用自己==
-   B.方法中的参数名或局部变量名应尽可能和字段名保持一致，方便阅读
-   C.调用特定对象的的非静态方法时，方法体会显式用this引用这个对象的实例变量、其他方法和属性
-   D.如果方法包含与字段同名的局部变量，则方法将引用字段而不是局部变量

4‌有关构造函数的说法，错误的是（ ）‎

-   A.每个类都必须至少有一个构造函数
-   B.当实现类的方法时，应使用类的属性来访问类的私有数据，这样可以减少代码维护的工作量，降低出错的可能性
-   ==C.不管是否显式的声明了构造函数，编译器都会创建默认的构造函数==
-   D.要重载构造函数，只需提供具有不同签名的多个构造函数声明

5‌有关析构函数和内存回收的描述正确的是（）‏

-   A.析构函数的名字由符号“\~”加类名组成，其中“\~”可以省略
-   B.在内存回收期回收对象的内存之前，析构函数由内存回收期调用，执行终止清理工作。析构函数和构造函数类似，可以重载
-   ==C.析构函数没有任何修饰符、没有任何参数、也不返回任何值==
-   D.析构函数可以被自动调用，也可以主动显示的调用

6下面对readonly和const修饰的实例变量不正确的是（ ）‍

-   A.const修饰的常量在声明的时候必须初始化; readonly修饰的常量则可以延迟到构造函数初始化。
-   B.静态常量（const）是指编译器在编译时候会对常量进行解析，并将常量的值替换成初始化的那个值。
-   C.动态常量（readonly）的值则是在运行的那一刻才获得的，编译器编译期间将其标示为只读常量，而不用常量的值代替，这样动态常量不必在声明的时候就初始化，而可以延迟到构造函数中初始化。
-   ==D.const是静态常量，所以必须要手动再为const增加一个static修饰符。==

7‎假设student类定义了Name,ClassInfor,StuNumber，利用对象初始化器student类的一个对象并初始化它的属性，下面写法正确的是（）‍

-   ==A.以上写法均正确==
-   B.student s1 =new student{Name=”ZhangSan”, ClassInfor =”IT201801”, StuNumber =”10000001”};
-   C.student s3 =new student{StuNumber =”10000001”};
-   D.student s2 =new student{ ClassInfor =”IT201801”, Name=”ZhangSan”, StuNumber =”10000001”};

8‏在visual studio窗口中，在（ ）窗口中可以查看当前项目的类和类型的层次信息‏

-   A.资源视图
-   ==B.类视图==
-   C.属性
-   D.解决方案管理器

9‍包装代码的三种常见途径是方法、类和名字空间。V

10基类的构造函数不被派生类继承。V

# 7

1‎继承具有（ ），即当基类本身也是某一类的派生类时，派生类会自动继承间接基类的成员。

-   A.重复性
-   B.多样性
-   C.规律性
-   ==D.传递性==

2‍派生类的对象对它的基类成员中的（ ）是不可访问的。

-   ==A.私有成员==
-   B.内部成员
-   C.保护成员
-   D.共有成员

3‏下列描述错误的是（ ）。‌

-   ==A.派生类对象可以不受限制地访问所有的基类对象==
-   B.在单一继承中，基类和它的派生存在一种层次关系
-   C.派生自同一个基类的不同类对象具有一些共同特征
-   D.派生类构造函数可以通过base关键字调用基类构造函数

4‌有一个基类A，下面选项中的A的派生类B写法正确是？‍

‌class A‍

‌{‍

‌  public int a;‍

‌  public A(int a)‍

‌  {‍

‌    this.a = a;‍

‌  }‍

‌}‍

-   ==A.==

    class B : A

     {

       public int b;

       public B(int a,int b):base(a)

       {

    ​     this.b = b;

       }

      }

-   B.

    class B : A

     {

       public int b;

       public B()

       {

    ​     b = 0;

       }

     }

-   C.

    class B : A

     {

       public int b;

       public B()

       {

    ​     b = 0;

       }

       public B(int a,int b):base(a)

       {

    ​     this.b = b;

       }

      }

-   D.

    class B 

     {

       public int b;

       public B(int a,int b):base(a)

       {

    ​     this.b = b;

       }

      }

5‏基类的protected成员只能在基类内部和派生类内部中访问。V

6‎基类的构造函数不被派生类继承。V

7所有的C#类都直接或间接继承自object类。V

8被sealed关键字修饰的方法不能被继承。V

# 8

1‏在C#中定义接口时，使用的关键字是‌

- A.overrides
- B.abstract
- ==C.interface==
- D.class

2‍下列说法正确的是
- ==A.接口的成员都必须是未实现的==
- B.类只能实现一个接口
- C.接口的成员前面可以加访问修饰符
- D.接口可以实例化

3‎关于虚方法实现多态，下列说法错误的是
- A.虚方法是实现多态的一种应用形式
- B.派生类是实现多态的一种应用形式
- ==C.关键字virtual可以与override一起使用==
- D.定义虚方法使用关键字virtual

4‎下列哪一个不是面向对象编程的特征‎
- A.封装
- B.多态
- C.继承
- ==D.统一接口==

5下列有关抽象类和虚方法的描述中，正确的是‍

- A.虚方法是一个非成员方法
- B.抽象类可以实例化其对象
- C.虚方法是一个static类型的成员方法
- ==D.抽象类是指具有抽象方法的类==
6‎下列描述是抽象类的特征是‍
- A.可以进行构造函数重载
- B.可以定义友元函数
- C.可以定义虚函数
- ==D.不能实例化其对象==

7有关对运算符重载的描述正确的是


- A.每个运算符都可以被重载成成员函数
- B.当需要时，可以自定义一个运算符进行重载
- ==C.运算符被重载时，它们的优先级与结合性不会发生改变==
- D.所有运算符都能被重载

8‍调用重载方法时，系统根据（ ）来选择具体方法‎

- A.方法的返回值类型
- B.方法名
- C.参数名和参数个数
- ==D.参数个数和类型==

9‍利用多态，根据方法调用的对象类型，相同的方法名和签名引起的行为相同。X
10抽象类中的所有方法都必须被声明为抽象的。X
11‏抽象基类的每个具体派生类，必须为基类的抽象方法和属性提供具体实现。V
12‏被sealed关键字修饰的方法不能被继承。V
